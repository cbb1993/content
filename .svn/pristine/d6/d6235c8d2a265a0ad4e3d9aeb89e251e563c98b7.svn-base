package com.huanhong.content.model.split.adaptive;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Rect;
import android.media.MediaPlayer;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.text.TextUtils;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;
import android.widget.VideoView;

import com.huanhong.content.R;
import com.huanhong.content.model.plan.Action;
import com.huanhong.content.model.plan.Content;
import com.huanhong.content.util.FileUtil;
import com.zyn.lib.util.MediaUtils;
import com.zyn.lib.util.Utils;
import com.zyn.lib.util.ViewUtils;

import java.util.List;

public class VideoAdapter extends Adapter
{
    private RelativeLayout mRelativeLayout;
    private VideoView mVideoView;
    private List<Content> mPathList;
    private String mCurr;
    private int mCount = -1;
    private long mStartTime = 0;
    private Boolean mIsNeedSeekTo = true;
    private Handler mWorkHandler;
    private HandlerThread mHandlerThread;
    private Handler mMainHandler;

    public VideoAdapter(Context context, List<Content> pathList, long startTime, boolean isNeedSeekTo)
    {
        super(context);
        mPathList = pathList;
        mStartTime = startTime;
        mIsNeedSeekTo = isNeedSeekTo;
    }

    @Override
    public void init()
    {
        mRelativeLayout = new RelativeLayout(getContext());
//        mRelativeLayout.setBackgroundColor(Color.GRAY);

        mMainHandler = new Handler(Looper.getMainLooper());
        mHandlerThread = new HandlerThread(getClass().getSimpleName());
        mHandlerThread.start();
        mWorkHandler = new Handler(mHandlerThread.getLooper());

        if (mPathList == null)
        {
            return;
        }

        RelativeLayout.LayoutParams layoutParams =new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
        layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT,RelativeLayout.TRUE);

        mVideoView = new VideoView(getContext());
        mVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener()
        {
            @Override
            public void onCompletion(MediaPlayer mp)
            {
                Log.e(getClass().getSimpleName(), " 视频结束");
                String url = getNextUrl();
                mCurr = url;
                mVideoView.setVideoPath(url);
                mVideoView.start();
            }
        });
        mVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener()
        {
            @Override
            public void onPrepared(MediaPlayer mp)
            {
                //设置MediaPlayer的OnSeekComplete监听
                mp.setOnSeekCompleteListener(new MediaPlayer.OnSeekCompleteListener()
                {
                    @Override
                    public void onSeekComplete(MediaPlayer mp)
                    {
                        if (!mp.isPlaying())
                        {
                            mVideoView.start();
                        }
                    }
                });
            }
        });
        mRelativeLayout.addView(mVideoView,layoutParams);

        mWorkHandler.post(new Runnable()
        {
            @Override
            public void run()
            {
                long duration = 0;
                final long curr = System.currentTimeMillis();
                if (mIsNeedSeekTo)
                {
                    duration = seekTo(curr - mStartTime);
                }
                final String url = getNextUrl();
                mCurr = url;

                final long finalDuration = duration;
                mMainHandler.post(new Runnable()
                {
                    @Override
                    public void run()
                    {
                        if (mVideoView != null)
                        {
                            mVideoView.setVideoPath(url);
                            long addition = System.currentTimeMillis() - curr;
                            mVideoView.seekTo((int) (finalDuration + addition));
                        }
                    }
                });
            }
        });


    }

    @Override
    public View getView()
    {
        return mRelativeLayout;
    }

    @Override
    public Content getCurrContent()
    {
        try
        {
            return mPathList.get(mCount);
        } catch (Exception e)
        {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public void deinit()
    {
        if (mVideoView == null)
        {
            return;
        }

        mVideoView.pause();
        mVideoView.stopPlayback();
        mVideoView = null;

        mRelativeLayout.removeAllViews();
        mRelativeLayout = null;

        if (mHandlerThread != null)
        {
            mHandlerThread.quitSafely();
        }
    }

    @Override
    public Bitmap getBitmapShot()
    {
        if (mVideoView != null && !TextUtils.isEmpty(mCurr))
        {
            //获得view背景
            Bitmap bg = ViewUtils.getViewShot(getView());
            if (bg == null)
            {
                return null;
            }

            //获得视频帧
            Bitmap bitmap = MediaUtils.getMediaKeyFrame(FileUtil.getPathByShowPath(mCurr), mVideoView.getCurrentPosition());
            if (bitmap != null)
            {
                Canvas canvas = new Canvas(bg);
                int bgWidth = bg.getWidth();
                int bgHeight = bg.getHeight();
                float bgRatio = (float) bgWidth / bgHeight;
                int bmWidth = bitmap.getWidth();
                int bmHeight = bitmap.getHeight();
                float bmRatio = (float) bmWidth / bmHeight;
                Rect rect = new Rect();
                //如果view宽高比大于视频宽高比
                if(bgRatio>bmRatio)
                {
                    int width = (int) (bgHeight * bmRatio);
                    rect.set((bgWidth-width)/2,0,bgWidth-(bgWidth-width)/2, bgHeight);
                }
                else
                {
                    int height = (int) (bgWidth / bmRatio);
                    rect.set(0,(bgHeight-height)/2, bgWidth,bgHeight-(bgHeight-height)/2);
                }
                canvas.drawBitmap(bitmap, new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight()), rect, null);
            }
            return bg;
        }
        return null;
    }

    private String getNextUrl()
    {
        if (mPathList == null)
        {
            return "";
        }

        if (++mCount >= mPathList.size())
        {
            if (Utils.isEmptyList(mPathList))
            {
                mCount = -1;
            } else
            {
                mCount = 0;
            }
        }

        Log.e(getClass().getSimpleName(), "当前播放次序: " + mCount);

        try
        {
            return FileUtil.getPathByShowPath(mPathList
                    .get(mCount)
                    .getShowPath());
        } catch (Exception e)
        {
            e.printStackTrace();
        }

        return "";
    }

    private long seekTo(long seekTo)
    {
        if (mPathList == null || seekTo < 0)
        {
            return 0;
        }

        //计数初始化
        mCount = -1;

        //获得播放列表总时长
        long total = getTotalMediaDuration();
        if (total == 0)
        {
            return 0;
        }

        //取余
        seekTo = seekTo % total;

        //计算seekTo位置
        for (int i = 0; i < mPathList.size(); i++)
        {
            long duration = MediaUtils.getMediaDuration(FileUtil.getPathByShowPath(mPathList
                    .get(i)
                    .getShowPath()));
            if (duration > seekTo)
            {
                mCount = i - 1;
                return seekTo;
            } else
            {
                seekTo = seekTo - duration;
            }
        }

        return 0;
    }

    private long getTotalMediaDuration()
    {
        if (mPathList == null)
        {
            return 0;
        }

        long total = 0;
        for (Content s : mPathList)
        {
            long t = MediaUtils.getMediaDuration(FileUtil.getPathByShowPath(s.getShowPath()));
            total += t;
        }
        return total;
    }
}
